
import com.example.config.RaftConfig;
import org.jgroups.JChannel;
import org.jgroups.protocols.*;
import org.jgroups.protocols.pbcast.*;
import org.jgroups.protocols.dns.DNS_PING;
import org.jgroups.protocols.kubernetes.KUBE_PING;
import org.jgroups.raft.RaftHandle;
import org.jgroups.raft.StateMachine;
import org.jgroups.stack.ProtocolStack;

import java.io.*;
import java.net.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Unified RAFT-replicated DDS stats cache:
 *  - auto-detects environment (K8s / Nomad / VM)
 *  - dynamic ports
 *  - leader aware
 *  - propagates metrics, membership, and periodic heartbeats
 */
public class ReplicatedDdsStatsCache implements StateMachine {

    private final DdsStatsCache localCache;
    private final RaftHandle raft;
    private final JChannel channel;
    private final Timer reconcileTimer = new Timer("dds-stats-sync", true);
    private final Timer heartbeatTimer = new Timer("dds-stats-heartbeat", true);

    public ReplicatedDdsStatsCache(RaftConfig cfg, DdsStatsCache localCache) throws Exception {
        this.localCache = localCache;

        DynamicRaftRegistry.resolveHostname(cfg);
        InetAddress bindAddr = InetAddress.getByName(cfg.getBindAddress());
        int port = cfg.getBindPort() == 0 ? getFreePort() : cfg.getBindPort();

        this.channel = new JChannel(false);
        ProtocolStack stack = new ProtocolStack();
        stack.setChannel(channel);
        stack.addProtocol(new TCP().setBindAddress(bindAddr).setBindPort(port));
        addDiscoveryProtocol(stack, cfg, port);

        stack.addProtocol(new MERGE3())
             .addProtocol(new FD_SOCK())
             .addProtocol(new FD_ALL())
             .addProtocol(new VERIFY_SUSPECT())
             .addProtocol(new BARRIER())
             .addProtocol(new NAKACK2())
             .addProtocol(new UNICAST3())
             .addProtocol(new STABLE())
             .addProtocol(new GMS())
             .addProtocol(new UFC())
             .addProtocol(new MFC())
             .addProtocol(new FRAG2())
             .addProtocol(new org.jgroups.raft.protocols.RAFT())
             .init();

        channel.setName(UUID.randomUUID().toString());
        this.raft = new RaftHandle(channel, this).raftId(channel.getName());
        channel.connect(cfg.getClusterName());

        // Listen for leader election and rebroadcast membership
      try {
    // Modern versions
    raft.getClass().getMethod("addRoleListener", RaftHandle.RoleChangeListener.class)
        .invoke(raft, (RaftHandle.RoleChangeListener) (oldRole, newRole) -> {
            System.out.printf("üëë RAFT role change: %s ‚Üí %s%n", oldRole, newRole);
            if (raft.isLeader()) {
                try {
                    replicateMembershipUpdate(DynamicRaftRegistry.getActiveMembers());
                } catch (Exception e) {
                    System.err.println("‚ö†Ô∏è Membership replication failed: " + e.getMessage());
                }
            }
        });
} catch (NoSuchMethodException e1) {
    // Fallback for older versions (addRoleChangeListener)
    try {
        raft.getClass().getMethod("addRoleChangeListener", RaftHandle.RoleChangeListener.class)
            .invoke(raft, (RaftHandle.RoleChangeListener) (oldRole, newRole) -> {
                System.out.printf("üëë RAFT role change: %s ‚Üí %s%n", oldRole, newRole);
                if (raft.isLeader()) {
                    try {
                        replicateMembershipUpdate(DynamicRaftRegistry.getActiveMembers());
                    } catch (Exception ex) {
                        System.err.println("‚ö†Ô∏è Membership replication failed: " + ex.getMessage());
                    }
                }
            });
    } catch (Exception inner) {
        throw new RuntimeException("‚ùå No suitable role listener method found in RaftHandle", inner);
    }
}


        // Heartbeat broadcaster (leader only)
        heartbeatTimer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                if (raft.isLeader()) {
                    try {
                        sendHeartbeat();
                    } catch (Exception e) {
                        System.err.println("‚ö†Ô∏è Heartbeat send failed: " + e.getMessage());
                    }
                }
            }
        }, 10000, 20000); // every 20s

        System.out.printf("‚úÖ Node [%s] started on %s:%d (cluster=%s)%n",
                channel.getName(), cfg.getBindAddress(), port, cfg.getClusterName());

        reconcileTimer.scheduleAtFixedRate(new TimerTask() {
            @Override public void run() {
                System.out.printf("üîÑ Node [%s] leader=%s cacheSize=%d%n",
                        channel.getName(), raft.isLeader(), localCache.asMap().size());
            }
        }, 15000, 30000);
    }

    // ---------------- StateMachine ----------------
    @Override
    public byte[] apply(byte[] data, int offset, int length, boolean serializeResponse) {
        try (DataInputStream dis = new DataInputStream(new ByteArrayInputStream(data, offset, length))) {
            String key = dis.readUTF();

            if ("__members__".equals(key)) {
                int n = dis.readInt();
                List<String> members = new ArrayList<>();
                for (int i = 0; i < n; i++) members.add(dis.readUTF());
                DynamicRaftRegistry.updateFromLeader(members);
                return null;
            }

            if ("__heartbeat__".equals(key)) {
                String leaderId = dis.readUTF();
                int n = dis.readInt();
                List<String> members = new ArrayList<>();
                for (int i = 0; i < n; i++) members.add(dis.readUTF());
                DynamicRaftRegistry.updateFromLeader(members);
                System.out.printf("üíì Heartbeat received from [%s], members now: %s%n", leaderId, members);
                return null;
            }

            double val = dis.readDouble();
            localCache.onReplicatedUpdate(key, val);
            System.out.printf("üì£ [%s] Replicated metric: %s=%f%n", channel.getName(), key, val);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    @Override public void readContentFrom(DataInput in) {}
    @Override public void writeContentTo(DataOutput out) {}

    // ---------------- Metric replication ----------------
    public void put(String key, double value) throws Exception {
        localCache.put(key, value);
        replicateMetric(key, value);
    }

    private void replicateMetric(String key, double value) throws Exception {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        DataOutputStream dos = new DataOutputStream(out);
        dos.writeUTF(key);
        dos.writeDouble(value);
        byte[] payload = out.toByteArray();
        raft.setAsync(payload, 0, payload.length)
            .exceptionally(ex -> { ex.printStackTrace(); return null; });
    }

    private void replicateMembershipUpdate(List<String> members) throws Exception {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        DataOutputStream dos = new DataOutputStream(out);
        dos.writeUTF("__members__");
        dos.writeInt(members.size());
        for (String m : members) dos.writeUTF(m);
        raft.setAsync(out.toByteArray(), 0, out.size())
            .exceptionally(ex -> { ex.printStackTrace(); return null; });
    }

    private void sendHeartbeat() throws Exception {
        List<String> members = DynamicRaftRegistry.getActiveMembers();
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        DataOutputStream dos = new DataOutputStream(out);
        dos.writeUTF("__heartbeat__");
        dos.writeUTF(channel.getName());
        dos.writeInt(members.size());
        for (String m : members) dos.writeUTF(m);
        raft.setAsync(out.toByteArray(), 0, out.size())
            .exceptionally(ex -> { ex.printStackTrace(); return null; });
        System.out.printf("üíì [%s] Heartbeat sent (members=%d)%n", channel.getName(), members.size());
    }

    public boolean isLeader() { return raft.isLeader(); }

    public void shutdown() {
        reconcileTimer.cancel();
        heartbeatTimer.cancel();
        channel.close();
        System.out.println("üõë RAFT node stopped");
    }

    // ---------------- Discovery logic ----------------
    private void addDiscoveryProtocol(ProtocolStack stack, RaftConfig cfg, int port) {
        String discovery = Optional.ofNullable(cfg.getDiscovery()).orElse("auto").toLowerCase();

        try {
            switch (discovery) {
                case "kube" -> {
                    KUBE_PING kube = new KUBE_PING();
                    kube.setValue("namespace", System.getenv().getOrDefault("KUBERNETES_NAMESPACE", "default"));
                    kube.setValue("label_selector", "app=" + cfg.getServiceName());
                    stack.addProtocol(kube);
                    System.out.printf("üåê Using KUBE_PING (label=app=%s)%n", cfg.getServiceName());
                }
                case "dns" -> {
                    DNS_PING dns = new DNS_PING();
                    dns.setValue("dns_query", cfg.getServiceName() + ".default.svc.cluster.local");
                    dns.setValue("dns_record_type", "A");
                    dns.setValue("timeout", "3000");
                    stack.addProtocol(dns);
                    System.out.printf("üåê Using DNS_PING (query=%s)%n", cfg.getServiceName());
                }
                case "tcp" -> {
                    configureDynamicTCPPing(stack, cfg, port);
                    System.out.println("üì° Using TCPPING (VM/Nomad dynamic)");
                }
                default -> {
                    if (isKubernetes()) {
                        KUBE_PING kube = new KUBE_PING();
                        kube.setValue("namespace", "default");
                        kube.setValue("label_selector", "app=" + cfg.getServiceName());
                        stack.addProtocol(kube);
                        System.out.println("ü§ñ Auto-detected K8s ‚Üí KUBE_PING");
                    } else {
                        configureDynamicTCPPing(stack, cfg, port);
                        System.out.println("ü§ñ Auto-detected VM/Nomad ‚Üí TCPPING");
                    }
                }
            }
        } catch (Exception e) {
            throw new RuntimeException("‚ùå Discovery configuration failed: " + e.getMessage(), e);
        }
    }

    private void configureDynamicTCPPing(ProtocolStack stack, RaftConfig cfg, int port) {
        List<String> members = DynamicRaftRegistry.registerAndGetMembers(cfg, port);
        List<InetSocketAddress> hosts = members.stream()
                .map(ReplicatedDdsStatsCache::parseInetSocketAddress)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
        stack.addProtocol(new TCPPING().setInitialHosts(hosts));
        System.out.printf("üì° Using dynamic TCPPING hosts: %s%n", hosts);
    }

    private static boolean isKubernetes() {
        return System.getenv("KUBERNETES_SERVICE_HOST") != null;
    }

    private static InetSocketAddress parseInetSocketAddress(String spec) {
        try {
            int start = spec.indexOf('[');
            int end = spec.indexOf(']');
            String host = (start > 0 && end > start) ? spec.substring(0, start) : spec;
            int port = 0;
            if (start > 0 && end > start) {
                String portStr = spec.substring(start + 1, end);
                port = portStr.isBlank() ? 0 : Integer.parseInt(portStr);
            }
            InetAddress addr = InetAddress.getByName(host);
            return new InetSocketAddress(addr, port);
        } catch (Exception e) {
            System.err.println("‚ö†Ô∏è Invalid host entry: " + spec + " (" + e.getMessage() + ")");
            return null;
        }
    }

    private static int getFreePort() {
        try (ServerSocket s = new ServerSocket(0)) {
            s.setReuseAddress(true);
            return s.getLocalPort();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
